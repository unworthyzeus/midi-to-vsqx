"""
Vocal Synthesis Format Generator Module
Generates vocal synthesis project files:
- VSQX (Vocaloid 4) - XML format
- VPR (Vocaloid 5/6) - JSON in ZIP format
- UST (UTAU) - INI-style format
- USTX (OpenUTAU) - YAML format
- SVP (Synthesizer V) - JSON format

Based on format specifications from UtaFormatix3 (Apache 2.0 License)
https://github.com/sdercolin/utaformatix3
"""

from enum import Enum
from typing import List, Dict, Tuple, Optional, Any
import xml.etree.ElementTree as ET
from xml.dom import minidom
import uuid
import json
import zipfile
import io
import yaml


class OutputFormat(Enum):
    """Supported vocal synthesis output formats"""
    VSQX = 'vsqx'   # Vocaloid 4 (XML)
    VPR = 'vpr'     # Vocaloid 5/6 (JSON in ZIP)
    UST = 'ust'     # UTAU (INI-style)
    USTX = 'ustx'   # OpenUTAU (YAML)
    SVP = 'svp'     # Synthesizer V (JSON)


# Constants from UtaFormatix
TICK_RATE_SVP = 1470000  # SynthV uses 1470000 blicks per quarter note
TICK_RATE = 480          # Standard MIDI ticks per quarter note
BPM_RATE = 100.0        # VPR tempo multiplier


# Voicebank database
SINGERS = {
    # Vocaloid 4
    'Miku_V4X': {'id': 'BHHP9W79F6TFRCD5', 'name': 'Hatsune Miku V4X', 'lang': 'Japanese'},
    'Luka_V4X': {'id': 'BCEY7S56V3TSW7FC', 'name': 'Megurine Luka V4X', 'lang': 'Japanese'},
    'Rin_V4X': {'id': 'BHEY7S79F6TFRCD5', 'name': 'Kagamine Rin V4X', 'lang': 'Japanese'},
    'Len_V4X': {'id': 'BHFY7S79F6TFRCD5', 'name': 'Kagamine Len V4X', 'lang': 'Japanese'},
    'GUMI_V4': {'id': 'BHGP9W79F6TFRCD5', 'name': 'Megpoid (GUMI) V4', 'lang': 'Japanese'},
    
    # UTAU
    'Teto': {'id': 'UTAU_TETO', 'name': 'Kasane Teto', 'lang': 'Japanese'},
    'Defoko': {'id': 'UTAU_DEFOKO', 'name': 'Defoko', 'lang': 'Japanese'},
    
    # SynthV
    'Solaria': {'id': 'SVP_SOLARIA', 'name': 'Solaria', 'lang': 'English'},
    'Eleanor': {'id': 'SVP_ELEANOR', 'name': 'Eleanor Forte', 'lang': 'English'},
    'Mai': {'id': 'SVP_MAI', 'name': 'Mai', 'lang': 'Japanese'},
    
    # Default
    'Default': {'id': 'DEFAULT', 'name': 'Default', 'lang': 'Japanese'},
}

SINGER_ALIASES = {
    'Miku': 'Miku_V4X', 'Luka': 'Luka_V4X', 'Rin': 'Rin_V4X', 'Len': 'Len_V4X', 'GUMI': 'GUMI_V4',
}


def get_singer(name: str) -> Dict:
    """Get singer info by name or alias"""
    if name in SINGER_ALIASES:
        name = SINGER_ALIASES[name]
    return SINGERS.get(name, SINGERS['Default'])


def generate_output(
    notes: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    output_format: OutputFormat = OutputFormat.VSQX,
    singer_name: str = 'Miku',
    project_name: str = 'Converted Project',
    similarity_score: float = 0.0
) -> bytes:
    """
    Generate a vocal synthesis project file
    
    Args:
        notes: List of note dicts with pitch, start, duration, lyric
        tempo: BPM
        time_signature: (numerator, denominator)
        output_format: Target format
        singer_name: Voicebank name
        project_name: Project name
        similarity_score: Lyrics match quality (0-1)
    
    Returns:
        Bytes of the output file
    """
    comment = f'Generated by MIDI to Voice Synth Converter (Match: {similarity_score*100:.1f}%)'
    
    if output_format == OutputFormat.VSQX:
        content = _generate_vsqx(notes, tempo, time_signature, singer_name, project_name, comment)
        return content.encode('utf-8')
    elif output_format == OutputFormat.VPR:
        return _generate_vpr(notes, tempo, time_signature, singer_name, project_name)
    elif output_format == OutputFormat.UST:
        content = _generate_ust(notes, tempo, singer_name, project_name)
        return content.encode('shift-jis', errors='replace')
    elif output_format == OutputFormat.USTX:
        content = _generate_ustx(notes, tempo, time_signature, singer_name, project_name)
        return content.encode('utf-8')
    elif output_format == OutputFormat.SVP:
        content = _generate_svp(notes, tempo, time_signature, singer_name, project_name)
        return content.encode('utf-8')
    else:
        raise ValueError(f"Unknown format: {output_format}")


def generate_multi_track_output(
    tracks: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    output_format: OutputFormat = OutputFormat.VSQX,
    singer_name: str = 'Miku'
) -> bytes:
    """Generate output with multiple tracks"""
    if output_format == OutputFormat.VSQX:
        content = _generate_vsqx_multi(tracks, tempo, time_signature, singer_name)
        return content.encode('utf-8')
    elif output_format == OutputFormat.VPR:
        return _generate_vpr_multi(tracks, tempo, time_signature, singer_name)
    elif output_format == OutputFormat.UST:
        # UST doesn't support multi-track, merge all notes
        all_notes = []
        for track in tracks:
            all_notes.extend(track.get('notes', []))
        all_notes.sort(key=lambda n: n.get('start_ticks', n['start']))
        content = _generate_ust(all_notes, tempo, singer_name, 'Multi-Track')
        return content.encode('shift-jis', errors='replace')
    elif output_format == OutputFormat.USTX:
        content = _generate_ustx_multi(tracks, tempo, time_signature, singer_name)
        return content.encode('utf-8')
    elif output_format == OutputFormat.SVP:
        content = _generate_svp_multi(tracks, tempo, time_signature, singer_name)
        return content.encode('utf-8')
    else:
        raise ValueError(f"Unknown format: {output_format}")


def get_file_extension(output_format: OutputFormat) -> str:
    """Get file extension for a format"""
    return '.' + output_format.value


def get_mime_type(output_format: OutputFormat) -> str:
    """Get MIME type for a format"""
    if output_format == OutputFormat.VSQX:
        return 'application/xml'
    elif output_format == OutputFormat.VPR:
        return 'application/zip'
    elif output_format == OutputFormat.UST:
        return 'text/plain; charset=shift-jis'
    elif output_format == OutputFormat.USTX:
        return 'application/x-yaml'
    elif output_format == OutputFormat.SVP:
        return 'application/json'
    return 'application/octet-stream'


# ============================================
# VSQX (Vocaloid 4) Generator
# Based on UtaFormatix Vsqx.kt
# ============================================

def _generate_vsqx(
    notes: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    singer_name: str,
    project_name: str,
    comment: str
) -> str:
    """Generate VSQX (Vocaloid 4) format"""
    singer = get_singer(singer_name)
    
    root = ET.Element('vsq4')
    root.set('xmlns', 'http://www.yamaha.co.jp/vocaloid/schema/vsq4/')
    root.set('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
    root.set('xsi:schemaLocation', 'http://www.yamaha.co.jp/vocaloid/schema/vsq4/ vsq4.xsd')
    
    ET.SubElement(root, 'vender').text = 'Yamaha corporation'
    ET.SubElement(root, 'version').text = '4.0.0.3'
    
    # Voice table
    voice_table = ET.SubElement(root, 'vVoiceTable')
    voice = ET.SubElement(voice_table, 'vVoice')
    ET.SubElement(voice, 'bs').text = '1'
    ET.SubElement(voice, 'pc').text = '0'
    ET.SubElement(voice, 'id').text = singer['id']
    ET.SubElement(voice, 'name').text = singer['name']
    
    v_prm = ET.SubElement(voice, 'vPrm')
    for param in ['bre', 'bri', 'cle', 'gen', 'ope']:
        ET.SubElement(v_prm, param).text = '0'
    
    # Mixer
    mixer = ET.SubElement(root, 'mixer')
    master_unit = ET.SubElement(mixer, 'masterUnit')
    ET.SubElement(master_unit, 'oDev').text = '0'
    ET.SubElement(master_unit, 'rLvl').text = '0'
    ET.SubElement(master_unit, 'vol').text = '0'
    
    vs_unit = ET.SubElement(mixer, 'vsUnit')
    ET.SubElement(vs_unit, 'tNo').text = '0'
    ET.SubElement(vs_unit, 'iGin').text = '0'
    ET.SubElement(vs_unit, 'sLvl').text = '-898'
    ET.SubElement(vs_unit, 'sEnable').text = '0'
    ET.SubElement(vs_unit, 'm').text = '0'
    ET.SubElement(vs_unit, 's').text = '0'
    ET.SubElement(vs_unit, 'pan').text = '64'
    ET.SubElement(vs_unit, 'vol').text = '0'
    
    for unit_name in ['monoUnit', 'stUnit']:
        unit = ET.SubElement(mixer, unit_name)
        ET.SubElement(unit, 'iGin').text = '0'
        if unit_name == 'monoUnit':
            ET.SubElement(unit, 'sLvl').text = '-898'
            ET.SubElement(unit, 'sEnable').text = '0'
        ET.SubElement(unit, 'm').text = '0'
        ET.SubElement(unit, 's').text = '0'
        if unit_name == 'monoUnit':
            ET.SubElement(unit, 'pan').text = '64'
        ET.SubElement(unit, 'vol').text = '-129' if unit_name == 'stUnit' else '0'
    
    # Master track
    master_track = ET.SubElement(root, 'masterTrack')
    ET.SubElement(master_track, 'seqName').text = project_name
    ET.SubElement(master_track, 'comment').text = comment
    ET.SubElement(master_track, 'resolution').text = str(TICK_RATE)
    measure_prefix = 4
    ET.SubElement(master_track, 'preMeasure').text = str(measure_prefix)
    
    time_sig = ET.SubElement(master_track, 'timeSig')
    ET.SubElement(time_sig, 'm').text = '0'
    ET.SubElement(time_sig, 'nu').text = str(time_signature[0])
    ET.SubElement(time_sig, 'de').text = str(time_signature[1])
    
    tempo_elem = ET.SubElement(master_track, 'tempo')
    ET.SubElement(tempo_elem, 't').text = '0'
    ET.SubElement(tempo_elem, 'v').text = str(int(tempo * BPM_RATE))
    
    # Calculate tick prefix
    ticks_per_measure = int(time_signature[0] * TICK_RATE * 4 / time_signature[1])
    tick_prefix = measure_prefix * ticks_per_measure
    
    # VS Track
    vs_track = ET.SubElement(root, 'vsTrack')
    ET.SubElement(vs_track, 'tNo').text = '0'
    ET.SubElement(vs_track, 'name').text = project_name
    ET.SubElement(vs_track, 'comment').text = project_name
    
    vs_part = ET.SubElement(vs_track, 'vsPart')
    ET.SubElement(vs_part, 't').text = str(tick_prefix)
    total_ticks = _get_total_ticks(notes)
    ET.SubElement(vs_part, 'playTime').text = str(total_ticks)
    ET.SubElement(vs_part, 'name').text = project_name
    ET.SubElement(vs_part, 'comment').text = ''
    
    # Singing style plugin
    s_plug = ET.SubElement(vs_part, 'sPlug')
    ET.SubElement(s_plug, 'id').text = 'ACA9C502-A04B-42b5-B2EB-5CEA36D16FCE'
    ET.SubElement(s_plug, 'name').text = 'VOCALOID2 Compatible Style'
    ET.SubElement(s_plug, 'version').text = '3.0.0.1'
    
    # Part style
    p_style = ET.SubElement(vs_part, 'pStyle')
    _add_vsqx_style_elements(p_style)
    
    # Singer reference
    singer_elem = ET.SubElement(vs_part, 'singer')
    ET.SubElement(singer_elem, 't').text = '0'
    ET.SubElement(singer_elem, 'bs').text = '1'
    ET.SubElement(singer_elem, 'pc').text = '0'
    
    # Add notes
    for note in notes:
        _add_vsqx_note(vs_part, note)
    
    ET.SubElement(vs_part, 'plane').text = '0'
    
    # Required empty tracks
    ET.SubElement(root, 'monoTrack')
    ET.SubElement(root, 'stTrack')
    
    # Aux
    aux = ET.SubElement(root, 'aux')
    ET.SubElement(aux, 'id').text = 'AUX_VST_HOST_CHUNK_INFO'
    ET.SubElement(aux, 'content').text = 'VlNDSwAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA='
    
    return _prettify_xml(root)


def _add_vsqx_style_elements(parent: ET.Element) -> None:
    """Add style elements for VSQX"""
    styles = [
        ('accent', '50'), ('bendDep', '8'), ('bendLen', '0'),
        ('decay', '50'), ('fallPort', '0'), ('opening', '127'), ('risePort', '0'),
    ]
    for id_val, val in styles:
        v_elem = ET.SubElement(parent, 'v')
        v_elem.set('id', id_val)
        v_elem.text = val


def _add_vsqx_note(parent: ET.Element, note: Dict) -> None:
    """Add a note element for VSQX"""
    note_elem = ET.SubElement(parent, 'note')
    
    pos_tick = note.get('start_ticks', int(note['start'] * TICK_RATE / 500))
    dur_tick = note.get('duration_ticks', int(note['duration'] * TICK_RATE / 500))
    
    ET.SubElement(note_elem, 't').text = str(int(pos_tick))
    ET.SubElement(note_elem, 'dur').text = str(max(1, int(dur_tick)))
    ET.SubElement(note_elem, 'n').text = str(note['pitch'])
    ET.SubElement(note_elem, 'v').text = str(note.get('velocity', 64))
    
    lyric = note.get('lyric', 'a')
    ET.SubElement(note_elem, 'y').text = lyric
    ET.SubElement(note_elem, 'p').text = note.get('phoneme', lyric)
    
    n_style = ET.SubElement(note_elem, 'nStyle')
    style_params = [
        ('accent', '50'), ('bendDep', '8'), ('bendLen', '0'), ('decay', '50'),
        ('fallPort', '0'), ('opening', '127'), ('risePort', '0'), ('vibLen', '0'), ('vibType', '0')
    ]
    for id_val, val in style_params:
        v_elem = ET.SubElement(n_style, 'v')
        v_elem.set('id', id_val)
        v_elem.text = val


def _generate_vsqx_multi(tracks: List[Dict], tempo: float, time_signature: Tuple[int, int], singer_name: str) -> str:
    """Generate multi-track VSQX"""
    # Simplified: merge all tracks into one for now
    all_notes = []
    for track in tracks:
        all_notes.extend(track.get('notes', []))
    all_notes.sort(key=lambda n: n.get('start_ticks', n['start']))
    return _generate_vsqx(all_notes, tempo, time_signature, singer_name, 'Multi-Track', 'Multi-track project')


# ============================================
# VPR (Vocaloid 5/6) Generator
# Based on UtaFormatix Vpr.kt
# ============================================

def _generate_vpr(
    notes: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    singer_name: str,
    project_name: str
) -> bytes:
    """Generate VPR (Vocaloid 5/6) format - ZIP containing sequence.json"""
    singer = get_singer(singer_name)
    
    # Build notes array
    vpr_notes = []
    for note in notes:
        pos_tick = note.get('start_ticks', int(note['start'] * TICK_RATE / 500))
        dur_tick = note.get('duration_ticks', int(note['duration'] * TICK_RATE / 500))
        
        vpr_notes.append({
            "lyric": note.get('lyric', 'a'),
            "phoneme": note.get('phoneme', 'a'),
            "isProtected": False,
            "pos": int(pos_tick),
            "duration": max(1, int(dur_tick)),
            "number": note['pitch'],
            "velocity": note.get('velocity', 64),
            "exp": {"opening": 127},
            "singingSkill": {
                "duration": int(dur_tick) // 3,
                "weight": {"pre": 64, "post": 64}
            },
            "vibrato": {"type": 0, "duration": 0}
        })
    
    # Calculate total duration
    total_ticks = _get_total_ticks(notes) if notes else 1920
    
    project = {
        "version": {"major": 5, "minor": 0, "revision": 0},
        "vender": "Yamaha Corporation",
        "title": project_name,
        "masterTrack": {
            "samplingRate": 44100,
            "loop": {"isEnabled": True, "begin": 0, "end": total_ticks},
            "tempo": {
                "isFolded": False,
                "height": 0.0,
                "global": {"isEnabled": False, "value": int(tempo * BPM_RATE)},
                "events": [{"pos": 0, "value": int(tempo * BPM_RATE)}]
            },
            "timeSig": {
                "isFolded": False,
                "events": [{"bar": 0, "numer": time_signature[0], "denom": time_signature[1]}]
            },
            "volume": {
                "isFolded": False,
                "height": 0.0,
                "events": [{"pos": 0, "value": 0}]
            }
        },
        "voices": [{"compID": singer['id'], "name": singer['name']}],
        "tracks": [{
            "type": 0,
            "name": project_name,
            "color": 0,
            "busNo": 0,
            "isFolded": False,
            "height": 0.0,
            "volume": {"isFolded": True, "height": 40.0, "events": [{"pos": 0, "value": 0}]},
            "panpot": {"isFolded": True, "height": 40.0, "events": [{"pos": 0, "value": 0}]},
            "isMuted": False,
            "isSoloMode": False,
            "parts": [{
                "pos": 0,
                "duration": total_ticks,
                "styleName": "No Effect",
                "voice": {"compID": singer['id'], "langID": 0},
                "midiEffects": [],
                "notes": vpr_notes
            }] if vpr_notes else []
        }]
    }
    
    # Create ZIP
    return _create_vpr_zip(project)


def _generate_vpr_multi(tracks: List[Dict], tempo: float, time_signature: Tuple[int, int], singer_name: str) -> bytes:
    """Generate multi-track VPR"""
    # Simplified: merge tracks
    all_notes = []
    for track in tracks:
        all_notes.extend(track.get('notes', []))
    all_notes.sort(key=lambda n: n.get('start_ticks', n['start']))
    return _generate_vpr(all_notes, tempo, time_signature, singer_name, 'Multi-Track')


def _create_vpr_zip(sequence: Dict) -> bytes:
    """Create VPR ZIP file"""
    buffer = io.BytesIO()
    with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        json_content = json.dumps(sequence, indent=2, ensure_ascii=False)
        zf.writestr('Project/sequence.json', json_content.encode('utf-8'))
    buffer.seek(0)
    return buffer.getvalue()


# ============================================
# UST (UTAU) Generator
# Based on UtaFormatix Ust.kt
# ============================================

def _generate_ust(
    notes: List[Dict],
    tempo: float,
    singer_name: str,
    project_name: str
) -> str:
    """Generate UST (UTAU) format"""
    singer = get_singer(singer_name)
    lines = []
    
    # Header
    lines.append('[#VERSION]')
    lines.append('UST Version1.2')
    lines.append('[#SETTING]')
    lines.append(f'Tempo={tempo:.2f}')
    lines.append('Tracks=1')
    lines.append(f'ProjectName={project_name}')
    lines.append(f'VoiceDir=%VOICE%{singer["name"]}')
    lines.append(f'OutFile={project_name}.wav')
    lines.append('CacheDir=cache')
    lines.append('Mode2=True')
    lines.append('')
    
    # Insert rests and notes
    tick_pos = 0
    note_count = 0
    
    for note in notes:
        pos_tick = note.get('start_ticks', int(note['start'] * TICK_RATE / 500))
        dur_tick = note.get('duration_ticks', int(note['duration'] * TICK_RATE / 500))
        dur_tick = max(60, int(dur_tick))
        
        # Insert rest if needed
        if pos_tick > tick_pos:
            rest_length = pos_tick - tick_pos
            lines.append(f'[#{note_count:04d}]')
            lines.append(f'Length={rest_length}')
            lines.append('Lyric=R')
            lines.append('NoteNum=60')
            lines.append('PreUtterance=')
            lines.append('')
            note_count += 1
        
        # Add note
        lines.append(f'[#{note_count:04d}]')
        lines.append(f'Length={dur_tick}')
        lines.append(f'Lyric={note.get("lyric", "a")}')
        lines.append(f'NoteNum={note["pitch"]}')
        lines.append('PreUtterance=')
        lines.append('PBType=5')
        lines.append('')
        
        tick_pos = pos_tick + dur_tick
        note_count += 1
    
    lines.append('[#TRACKEND]')
    lines.append('')
    
    return '\r\n'.join(lines)


# ============================================
# USTX (OpenUTAU) Generator
# Based on UtaFormatix Ustx.kt
# ============================================

def _generate_ustx(
    notes: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    singer_name: str,
    project_name: str
) -> str:
    """Generate USTX (OpenUTAU) format - YAML"""
    singer = get_singer(singer_name)
    
    # Build notes list
    ustx_notes = []
    for note in notes:
        pos_tick = note.get('start_ticks', int(note['start'] * TICK_RATE / 500))
        dur_tick = note.get('duration_ticks', int(note['duration'] * TICK_RATE / 500))
        dur_tick = max(60, int(dur_tick))
        
        ustx_notes.append({
            'position': int(pos_tick),
            'duration': dur_tick,
            'tone': note['pitch'],
            'lyric': note.get('lyric', 'a'),
            'pitch': {'data': [{'x': -1, 'y': 0, 'shape': 'io'}, {'x': 1, 'y': 0, 'shape': 'io'}], 'snap_first': True},
            'vibrato': {'length': 0, 'period': 175, 'depth': 25, 'in': 10, 'out': 10, 'shift': 0, 'drift': 0},
            'phoneme_expressions': [],
            'phoneme_overrides': []
        })
    
    project = {
        'name': project_name,
        'comment': '',
        'output_dir': 'Vocal',
        'cache_dir': 'UCache',
        'ustx_version': '0.6',
        'resolution': TICK_RATE,
        'bpm': tempo,
        'beat_per_bar': time_signature[0],
        'beat_unit': time_signature[1],
        'time_signatures': [{'bar_position': 0, 'beat_per_bar': time_signature[0], 'beat_unit': time_signature[1]}],
        'tempos': [{'position': 0, 'bpm': tempo}],
        'expressions': _get_ustx_expressions(),
        'tracks': [{'phonemizer': 'OpenUtau.Core.DefaultPhonemizer', 'mute': False, 'solo': False, 'volume': 0}],
        'voice_parts': [{
            'name': project_name,
            'comment': '',
            'track_no': 0,
            'position': 0,
            'notes': ustx_notes,
            'curves': []
        }],
        'wave_parts': []
    }
    
    return yaml.dump(project, allow_unicode=True, default_flow_style=False, sort_keys=False)


def _get_ustx_expressions() -> Dict:
    """Get default USTX expressions"""
    return {
        'vel': {'name': 'velocity', 'abbr': 'vel', 'type': 'Numerical', 'min': 0, 'max': 200, 'default_value': 100, 'is_flag': False, 'flag': ''},
        'vol': {'name': 'volume', 'abbr': 'vol', 'type': 'Numerical', 'min': 0, 'max': 200, 'default_value': 100, 'is_flag': False, 'flag': ''},
        'gen': {'name': 'gender', 'abbr': 'gen', 'type': 'Numerical', 'min': -100, 'max': 100, 'default_value': 0, 'is_flag': True, 'flag': 'g'},
    }


def _generate_ustx_multi(tracks: List[Dict], tempo: float, time_signature: Tuple[int, int], singer_name: str) -> str:
    """Generate multi-track USTX"""
    # Merge tracks
    all_notes = []
    for track in tracks:
        all_notes.extend(track.get('notes', []))
    all_notes.sort(key=lambda n: n.get('start_ticks', n['start']))
    return _generate_ustx(all_notes, tempo, time_signature, singer_name, 'Multi-Track')


# ============================================
# SVP (Synthesizer V) Generator
# Based on UtaFormatix Svp.kt
# ============================================

def _generate_svp(
    notes: List[Dict],
    tempo: float,
    time_signature: Tuple[int, int],
    singer_name: str,
    project_name: str
) -> str:
    """Generate SVP (Synthesizer V) format - JSON"""
    singer = get_singer(singer_name)
    track_uuid = str(uuid.uuid4())
    
    # Convert notes to SVP format (blicks)
    svp_notes = []
    for note in notes:
        pos_tick = note.get('start_ticks', int(note['start'] * TICK_RATE / 500))
        dur_tick = note.get('duration_ticks', int(note['duration'] * TICK_RATE / 500))
        
        # Convert to blicks
        pos_blick = int(pos_tick * TICK_RATE_SVP / TICK_RATE)
        dur_blick = int(dur_tick * TICK_RATE_SVP / TICK_RATE)
        dur_blick = max(TICK_RATE_SVP // 16, dur_blick)
        
        svp_notes.append({
            "onset": pos_blick,
            "duration": dur_blick,
            "lyrics": note.get('lyric', 'la'),
            "phonemes": "",
            "pitch": note['pitch'],
            "attributes": {}
        })
    
    project = {
        "version": 113,
        "time": {
            "meter": [{"index": 0, "numerator": time_signature[0], "denominator": time_signature[1]}],
            "tempo": [{"position": 0, "bpm": tempo}]
        },
        "library": [],
        "tracks": [{
            "name": project_name,
            "dispColor": "ff7db235",
            "dispOrder": 0,
            "renderEnabled": True,
            "mixer": {"gainDecibel": 0.0, "pan": 0.0, "mute": False, "solo": False, "display": True},
            "mainGroup": {
                "name": "main",
                "uuid": track_uuid,
                "parameters": {
                    "pitchDelta": {"mode": "cubic", "points": []},
                    "vibratoEnv": {"mode": "cubic", "points": []},
                    "loudness": {"mode": "cubic", "points": []},
                    "tension": {"mode": "cubic", "points": []},
                    "breathiness": {"mode": "cubic", "points": []},
                    "voicing": {"mode": "cubic", "points": []},
                    "gender": {"mode": "cubic", "points": []}
                },
                "notes": svp_notes
            },
            "mainRef": {
                "groupID": track_uuid,
                "blickOffset": 0,
                "pitchOffset": 0,
                "isInstrumental": False,
                "database": {"name": singer['name'], "language": singer.get('lang', ''), "phoneset": ""},
                "audio": {"filename": "", "duration": 0.0},
                "dictionary": "",
                "voice": {}
            },
            "groups": []
        }],
        "renderConfig": {
            "destination": "./",
            "filename": project_name,
            "numChannels": 1,
            "aspirationFormat": "noAspiration",
            "bitDepth": 16,
            "sampleRate": 44100,
            "exportMixDown": True
        }
    }
    
    return json.dumps(project, indent=2, ensure_ascii=False)


def _generate_svp_multi(tracks: List[Dict], tempo: float, time_signature: Tuple[int, int], singer_name: str) -> str:
    """Generate multi-track SVP"""
    # Merge tracks
    all_notes = []
    for track in tracks:
        all_notes.extend(track.get('notes', []))
    all_notes.sort(key=lambda n: n.get('start_ticks', n['start']))
    return _generate_svp(all_notes, tempo, time_signature, singer_name, 'Multi-Track')


# ============================================
# Utility Functions
# ============================================

def _get_total_ticks(notes: List[Dict]) -> int:
    """Calculate total duration in ticks"""
    if not notes:
        return 1920
    last_note = max(notes, key=lambda n: n.get('start_ticks', n['start']) + n.get('duration_ticks', n['duration']))
    end_tick = last_note.get('start_ticks', 0) + last_note.get('duration_ticks', TICK_RATE)
    return int(end_tick + TICK_RATE)


def _prettify_xml(elem: ET.Element) -> str:
    """Pretty-print XML with declaration"""
    rough_string = ET.tostring(elem, encoding='unicode')
    reparsed = minidom.parseString(rough_string)
    xml_str = reparsed.toprettyxml(indent='  ')
    if xml_str.startswith('<?xml'):
        newline_pos = xml_str.find('?>')
        xml_str = '<?xml version="1.0" encoding="UTF-8"?>' + xml_str[newline_pos + 2:]
    return xml_str


# Legacy compatibility aliases
VSQXVersion = OutputFormat
generate_vsqx = generate_output
generate_multi_track_vsqx = generate_multi_track_output

# Keep old SINGERS format for backward compatibility
DEFAULT_SINGERS = {k: {'id': v['id'], 'name': v['name']} for k, v in SINGERS.items()}
